using Toybox.WatchUi as Ui;
using Toybox.Application as App;
using Toybox.Graphics as Gfx;
using Toybox.Math as Math;
using Toybox.System as System;
using Toybox.Lang as Lang;
using Toybox.Position;

// a class for navigation targets
class NavTarget {
    var name;		// the name of the navigation point
    var latitude;	// latitude in radians (positive north)
    var longitude;	// longitude in radians (positive east)
    // the constructor gets the coordinates in degrees
    // and converts them into radians
    function initialize(s,lat,lon) {
    	name = s;
    	latitude = lat * Math.PI/180.0d;
    	longitude = lon * Math.PI/180.0d;
    }
    // the NavTarget can compute its drection and distance
    // from another location given as Toybox::Position::Location object
    // if something goes wrong "ERR" strings are returned instead of numeric values
    function from(location) {
    	// System.print("NavTarget : ");
    	var dist = "ERR";
    	var bearing = "ERR";
    	if (location != null) {
    		// this type check leads to an abort on my Fenix 3 HR
        	// if (location instanceof Toybox.Position.Location) {
       		// System.print("location ");
	        var lat = location.toRadians()[0];
   		    var lon = location.toRadians()[1];
   			// System.println(Lang.format("from($1$ $2$) called.", [lat,lon]));
   			// spherical geometry cosine rule
	    	// compute the angular span along the orthodrome
   		    var cos_zeta = Math.sin(lat)*Math.sin(latitude) + Math.cos(lat)*Math.cos(latitude)*Math.cos(longitude-lon);
   		    var zeta = 0.0d;
   	    	if ((cos_zeta<=1.0d) && (cos_zeta>=-1.0d)) {
    	    	zeta = Math.acos(cos_zeta);
   		    }
    	    dist = zeta * 6371.0d;
        	// System.println(Lang.format("NavTarget zeta=$1$  dist=$2$", [zeta,dist]));
	        if (dist>0.01d) {
	    	    var sin_zeta = Math.sin(zeta);
   		    	var zeta_deg = zeta*180.0d/Math.PI;
    		    // the bearing angle
    	    	var cos_a = 2.0d;  // give it an illegal value to check later
	    	    if (Math.cos(lat)*sin_zeta > 1e-6d) {
   		    		cos_a = (Math.sin(latitude)-Math.sin(lat)*cos_zeta) / (Math.cos(lat)*sin_zeta);
   		    	} 
      		    var alpha = 0.0d;
      	    	if ((cos_a<=1.0d) && (cos_a>=-1.0d)) {
    		    	alpha = Math.acos(cos_a);
   			    }
   			    if (longitude>=lon) {
       			    bearing = 180.0d/Math.PI * alpha;
	        	} else {
   		    		bearing = 360.0d - 180.0f/Math.PI * alpha;
       			}
       		} else {
       			bearing = 0.0d;
       		}
        }
        // System.println(Lang.format("DST=$1$ BRG=$2$ : NavTarget", [dist,bearing]));
        return {"DST"=>dist, "BRG"=>bearing };
    }
}

class FlightNavView extends Ui.DataField {

	// const TARGET_FONT = Gfx.FONT_SYSTEM_MEDIUM;
	const TARGET_FONT = Gfx.FONT_LARGE;
	const TARGET_JUST = Gfx.TEXT_JUSTIFY_CENTER;
	const LABEL_FONT = Gfx.FONT_XTINY;
	const LABEL_JUST = Gfx.TEXT_JUSTIFY_LEFT;
	const VALUE_FONT = Gfx.FONT_NUMBER_MEDIUM;
	const VALUE_JUST = Gfx.TEXT_JUSTIFY_RIGHT;
	// const CLOCK_FONT = Gfx.FONT_SYSTEM_MEDIUM;
	const CLOCK_FONT = Gfx.FONT_LARGE;
	const CLOCK_JUST = Gfx.TEXT_JUSTIFY_CENTER;
    
    // the current navigation target
    var target = null;
    // the (initially empty) list of availavble targets
    var LOT;
    var LOT_index;
    var NOT;
    
	// a FIFO stack for positions
	// we need the position 10 seconds ago to compute the tracking angle
    // the number of tracking positions to be stored
    const TRACK_LENGTH = 10d;
    // array of stored track positions
    var TRK = new [0];
    
	// these are the display values
	// all are strings generated by compute() and shown by onUpdate()
	// direction to target position [rad]
	var bearing_to_target = "---";
	// disctance to target position [km]
	var distance_to_target = "---";
	// ground speed [km/h]
	var groundspeed = "---";
	// direction over ground [rad]
	var ground_track = "n.a.";

    function initialize() {
        DataField.initialize();
        
        // read the settings and build the list of targets
        LOT = new [0];
        // the number of available targets
        var app = Application.getApp();
        NOT = app.getProperty("numberTargets");
        // the first target
        var tname = app.getProperty("nameTarget1");
        var slat = app.getProperty("latTarget1");
        var slon = app.getProperty("lonTarget1");
        var lat = slat.toFloat();
        var lon = slon.toFloat();
        // System.println(Lang.format("$1$ $2$ $3$", [tname,lat,lon]));
        LOT.add(new NavTarget(tname, lat, lon));
        if (NOT>=2) {
	        tname = app.getProperty("nameTarget2");
    	    slat = app.getProperty("latTarget2");
        	slon = app.getProperty("lonTarget2");
        	lat = slat.toFloat();
        	lon = slon.toFloat();
        	// System.println(Lang.format("$1$ $2$ $3$", [tname,lat,lon]));
        	LOT.add(new NavTarget(tname, lat, lon));
        }
        if (NOT>=3) {
	        tname = app.getProperty("nameTarget3");
    	    slat = app.getProperty("latTarget3");
        	slon = app.getProperty("lonTarget3");
        	lat = slat.toFloat();
        	lon = slon.toFloat();
        	// System.println(Lang.format("$1$ $2$ $3$", [tname,lat,lon]));
        	LOT.add(new NavTarget(tname, lat, lon));
        }
        if (NOT>=4) {
	        tname = app.getProperty("nameTarget4");
    	    slat = app.getProperty("latTarget4");
        	slon = app.getProperty("lonTarget4");
        	lat = slat.toFloat();
        	lon = slon.toFloat();
        	// System.println(Lang.format("$1$ $2$ $3$", [tname,lat,lon]));
        	LOT.add(new NavTarget(tname, lat, lon));
        }
        if (NOT>=5) {
	        tname = app.getProperty("nameTarget5");
    	    slat = app.getProperty("latTarget5");
        	slon = app.getProperty("lonTarget5");
        	lat = slat.toFloat();
        	lon = slon.toFloat();
        	// System.println(Lang.format("$1$ $2$ $3$", [tname,lat,lon]));
        	LOT.add(new NavTarget(tname, lat, lon));
        }
        
        // make sure there always is at least one target defined
        if (LOT.size()==0) {
        	LOT.add(new NavTarget("HOME", 51.040318d, 13.874674d));
        }
        // first one is current
        LOT_index = 0;
        target = LOT[LOT_index];
        NOT = LOT.size();
    }

    // get the current location data and compute display values
    // compute() and onUpdate() may be called asynchronously
    // compute() is called when the info is updated
    // compute handles everything to generate the display strings
	function compute(info) {
        
        // System.println(" ");
        // System.println("compute()");
        // see if we have a GPS lock (at least "usable")
        // GPS quality (0...4 : not available - last known - poor - usable - good)
        var gps_lock = false;
        if (info != null) {
	        if (info.currentLocationAccuracy != null) {
	            // System.println(Lang.format("GPS quality = $1$", [info.currentLocationAccuracy]));
    	        if (info.currentLocationAccuracy >= 3) {
        	        gps_lock = true;
        } } }

		// analyze available GPS data
		if (gps_lock) {
			groundspeed = info.currentSpeed;
            if (groundspeed != null) {
                groundspeed = 3.6d * groundspeed;
                groundspeed = groundspeed.format("%.1f");
                // System.println(Lang.format("GS = $1$", [groundspeed]));
            }
            var location = info.currentLocation;
            if (location != null) {
                // System.println("have location");
                // System.println(location.toGeoString(Position.GEO_DMS));
                if (target != null) {
                	// System.println("have target");
	                var navi = target.from(location);
    	            distance_to_target = navi["DST"];
        	        if (distance_to_target instanceof Toybox.Lang.Double) {
            	    	distance_to_target = distance_to_target.format("%.1f");
                	}
	                bearing_to_target = navi["BRG"];
    	            if (bearing_to_target instanceof Toybox.Lang.Double) {
        	        	bearing_to_target = bearing_to_target.format("%d");
            	    }
            	} else {
            	    // System.println("no target");
            		distance_to_target = "---";
            		bearing_to_target = "---";
            	}
	            // store the current position as last position in the track
    	        if (TRK.size() >= TRACK_LENGTH) {
        	    	// remove earlier points
            		TRK = TRK.slice(1,TRACK_LENGTH);
	            }	
    	        TRK.add(location);
        	    // System.println(Lang.format("TRK[$1$] : $2$", [TRK.size(),TRK[0].toDegrees()]));
            	// if the track is long enough compute the direction
    	        var last = new NavTarget("",location.toDegrees()[0],location.toDegrees()[1]);
        	    ground_track = last.from(TRK[0])["BRG"];
   	            if (ground_track instanceof Toybox.Lang.Double) {
       	        	ground_track = ground_track.format("%d");
           	    }
            }
		} else {
		    distance_to_target = "---";
		    bearing_to_target = "---";
            groundspeed = "---";
            ground_track = "---";
		}
        // System.println(Lang.format("computed [$1$  $2$  $3$  $4$]", [bearing_to_target, groundspeed, ground_track, distance_to_target]));
	}

    // Display the value you computed here. This will be called
    // once a second when the data field is visible.
    function onUpdate(dc) {

        var width = dc.getWidth();
        var height = dc.getHeight();
        var backgroundColor = getBackgroundColor();
        // set background color
        dc.setColor(backgroundColor, Graphics.COLOR_TRANSPARENT);
        dc.fillRectangle (0, 0, width, height);
        // set foreground color
        dc.setColor((backgroundColor == Gfx.COLOR_BLACK) ? Gfx.COLOR_WHITE : Gfx.COLOR_BLACK, Graphics.COLOR_TRANSPARENT);
		// draw top and bottom fields (target and time)
		var tgt = Lang.format("$1$/$2$", [LOT_index+1,NOT]);
        dc.drawText(width/2, height/2-105, LABEL_FONT, tgt, TARGET_JUST);
        dc.drawText(width/2, height/2-94, TARGET_FONT, target.name, TARGET_JUST);
        // compute and display UTC time
        var clockTime = System.getClockTime();
        var timezone = clockTime.timeZoneOffset;
        var timesec = (clockTime.hour*60+clockTime.min)*60+clockTime.sec;
        var utctime = timesec-timezone;
        if (utctime<0) { utctime+=24*3600; }
        var clockHour = Math.floor(utctime/3600);
        var clockMin = Math.floor((utctime-3600*clockHour)/60);
        var clockSec = utctime-3600*clockHour-60*clockMin;
        var time = Lang.format("$1$:$2$:$3$", [clockHour, clockMin.format("%.2d"), clockSec.format("%.2d")]);
        dc.drawText(width/2, height/2+55, CLOCK_FONT, time, CLOCK_JUST);
        // System.println(Lang.format("onUpdate() $1$", [time]));
 
        // draw all data fields
        dc.drawLine(width/2-10, height/2-56, width/2-10, height/2+56);
        dc.drawLine(0, height/2-56, width, height/2-56);
        dc.drawText(width/2-90, height/2-55, LABEL_FONT, "BRG", LABEL_JUST);
       	dc.drawText(width/2-15, height/2-58, VALUE_FONT, bearing_to_target, VALUE_JUST);
        dc.drawText(width/2 -5, height/2-55, LABEL_FONT, "DST", LABEL_JUST);
        dc.drawText(width/2 -5, height/2-20, LABEL_FONT, "km", LABEL_JUST);
        dc.drawText(width/2+85, height/2-58, VALUE_FONT, distance_to_target, VALUE_JUST);
        dc.drawLine(0, height/2, width, height/2);
        dc.drawText(width/2-90, height/2+1, LABEL_FONT, "TRK", LABEL_JUST);
        dc.drawText(width/2-15, height/2-2, VALUE_FONT, ground_track, VALUE_JUST);
        dc.drawText(width/2 -5, height/2+1, LABEL_FONT, "GS", LABEL_JUST);
        dc.drawText(width/2 -5, height/2+36, LABEL_FONT, "km/h", LABEL_JUST);
        dc.drawText(width/2+85, height/2-2, VALUE_FONT, groundspeed, VALUE_JUST);
        dc.drawLine(0, height/2+56, width, height/2+56);
        // System.println(Lang.format("[$1$  $2$  $3$  $4$]", [bearing_to_target, groundspeed, ground_track, distance_to_target]));

    }

	// what should be done when the start/stop button is pressed
	// nothing - this is used for the recording start/stop
    function onTimerStart(){
    }
                
	// what should be done when the back/lap button is pressed
	// switch to the next target point
	// before this function is called the lap routine is activated - can't prevent that
	// maybe explicitly call onUpdate() so the view is restored quickly - doesn't work
	function onTimerLap(){
		LOT_index += 1;
		if (LOT_index >= LOT.size()) {
			LOT_index = 0;
		}
		target = LOT[LOT_index];
		Ui.requestUpdate();
	}        

}
